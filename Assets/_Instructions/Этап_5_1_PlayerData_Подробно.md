# Урок 5.1: PlayerData — ScriptableObject с базовыми данными игрока

## 0. Теория и темы урока

В этом уроке вы не просто создаёте ещё один скрипт, а закладываете фундамент архитектуры игрока. Здесь важно понять три вещи:

- **Что такое ScriptableObject**:  
  - особый тип `ScriptableObject` в Unity позволяет хранить **данные** в отдельных `.asset`‑файлах, а не в компонентах на сцене;  
  - один и тот же `PlayerData` можно переиспользовать в разных сценах и префабах, не дублируя настройки;  
  - ScriptableObject удобно использовать для баланса (характеристики, таблицы урона, настройки оружия и т.п.).

- **ООП**:  
  - объектно‑ориентированное программирование рассматривает программу как набор **объектов**, у каждого из которых есть данные (поля) и поведение (методы);  
  - цель ООП — приближать код к тому, как мы описываем вещи в реальном мире: “у игрока ЕСТЬ здоровье и мана, он УМЕЕТ двигаться и прыгать”;  
  - важные идеи ООП:
    - **инкапсуляция** — объект скрывает внутреннюю “кухню” и предоставляет только понятные методы (`TakeDamage`, а не `currentHealth = ...`);  
    - **наследование** — можно вынести общее поведение в базовый класс и расширять его в дочерних (например, общий `Character`, от которого унаследованы `Player` и `Enemy`);  
    - **полиморфизм** — работать с разными объектами через один общий тип/интерфейс (например, список `IDamageable`, в котором и игрок, и враги);  
    - **абстракция** — нас интересует “что объект делает”, а не “как он это делает внутри”.

- **Как связаны ООП и SOLID**:  
  - SOLID — это набор из 5 принципов, которые помогают писать **хороший ООП‑код**: читаемый, расширяемый и поддерживаемый;  
  - на примере системы игрока:
    - **S — Single Responsibility**: каждый класс отвечает за одну зону ответственности (`PlayerData` — данные, `PlayerStats` — состояние, `PlayerController` — движение);  
    - **O — Open/Closed**: мы расширяем поведение игрока новыми компонентами (например, `PlayerProgression`), не ломая существующие `PlayerData`/`PlayerStats`/`PlayerController`;  
    - **L — Liskov Substitution**: если позже появится базовый `Character` и наследники `PlayerCharacter`/`EnemyCharacter`, они должны подменять `Character` без сюрпризов для остального кода;  
    - **I — Interface Segregation**: вместо одного “толстого” интерфейса можно выделить маленькие (`IDamageable`, `IHealable`, `IMovable`) и давать классу только то, что ему нужно;  
    - **D — Dependency Inversion**: высокоуровневый код (например, контроллер движения) в идеале зависит от абстракций (интерфейса ввода), а не от конкретной реализации (`InputManager`), чтобы её можно было подменить.

- **Принципы ООП на примере игрока**:  
  В архитектуре игрока мы сознательно разделяем роли:
  - `PlayerData` — хранит **базовые числа** (макс. здоровье, мана, скорость, сила прыжка, ускорение, скорость поворота);  
  - `PlayerStats` — хранит **текущее состояние** (сколько HP/MP сейчас) и даёт методы `TakeDamage`, `Heal`, `AddMana`;  
  - `PlayerController` — занимается **движением и прыжком**, читая ввод и используя скорость из `PlayerStats.playerData`.  
  Это пример принципа **Single Responsibility**: каждый класс отвечает за одну задачу, а не «делает всё сразу».

- **Принципы SOLID (очень кратко)** и как они проявляются здесь:
  - **S — Single Responsibility**: у нас отдельные классы для данных (`PlayerData`), состояния (`PlayerStats`), движения (`PlayerController`);  
  - **O — Open/Closed**: мы можем добавлять новые компоненты (например, `PlayerProgression`) **не меняя** существующие `PlayerData`/`PlayerStats`;  
  - **L — Liskov Substitution**: пока просто запомни, что наследники должны вести себя как базовый тип без сюрпризов — это пригодится позже;  
  - **I — Interface Segregation**: лучше несколько маленьких интерфейсов, чем один огромный — на этапе игрока мы только подводим к этой идее через разделение ролей;  
  - **D — Dependency Inversion**: высокоуровневые классы должны зависеть от абстракций, а не от конкретных реализаций — в будущем можно будет заменить `PlayerData`/`PlayerStats` на другие источники данных, не переписывая логику движения.

Важная мысль: **мы строим систему из небольших, понятных блоков (компонентов), которые знают только свою ответственность и общаются через данные и события.**

## Дополнительно 

- **Чем ScriptableObject отличается от MonoBehaviour и префаба**:  
  - `MonoBehaviour` живёт **на сцене** (или в префабе) и участвует в игровом цикле (`Update`, `Start` и т.д.);  
  - `ScriptableObject` — это **чистые данные**, он сам по себе ничего “не делает” и не висит на сцене;  
  - префаб — это заготовка объекта со всеми компонентами, а ScriptableObject — заготовка **чисел/настроек**, которые эти компоненты могут читать.

- **Сериализация и Inspector**:  
  - Unity умеет **сериализовать** (сохранять) публичные поля и помеченные атрибутами `[SerializeField]` значения в сценах, префабах и `.asset`‑файлах.
- В `PlayerData` поля сделаны видимыми в Inspector специально, чтобы:
  - можно было править числа (здоровье, скорость и т.п.) без изменения кода;
  - один и тот же `PlayerData` использовался в нескольких сценах/префабах.
- Атрибуты `[Header]`, `[Tooltip]`, `[Min]` не влияют на логику — они помогают:
  - навести порядок в Inspector;
  - подсказать, что означает каждое поле.

- **Жизненный цикл ScriptableObject**:  
  - `PlayerData` не создаётся/уничтожается на сцене, как обычные объекты — он существует как ассет в проекте;  
  - один и тот же `PlayerData_Default` может использоваться сразу несколькими префабами/сценами;  
  - важно помнить, что при изменении `PlayerData` во время игры (через код) вы меняете сам ассет — это затрагивает все сцены (для серьёзных проектов лучше хранить “боевое” состояние отдельно, как это делает `PlayerStats`).

- **Несколько вариаций игрока через разные PlayerData**:  
- На основе одного и того же класса `PlayerData` можно создать **несколько ассетов**:
  - `PlayerData_Knight` — больше здоровье, меньше скорость;
  - `PlayerData_Rogue` — меньше здоровье, выше скорость и ускорение;
  - `PlayerData_Mage` — среднее здоровье, много маны и т.п.
- При этом:
  - код `PlayerStats` и `PlayerController` остаётся **одним и тем же**;
  - меняются только ссылки на разные `PlayerData` в Inspector.
- Это хороший пример:
  - разделения **данных** и **логики**;
  - переиспользования кода для разных “классов” персонажа.

- **Поля vs локальные переменные и инкапсуляция**:  
  - **Поля класса** (`maxHealth`, `currentHealth`, `moveSpeed` и т.д.):
  - объявлены внутри класса, но **вне** методов;
  - хранят состояние объекта **между кадрами**;
  - видны всем методам этого класса и (если `public`) — другим скриптам.

- **Локальные переменные**:
  - объявляются **внутри метода** (`float damage = 10f;`);
  - живут только пока выполняется этот метод;
  - используются для временных расчётов.

- **Частые ошибки и как их избежать**:  
  - **Не назначен PlayerData в PlayerStats**:
  - в коде есть проверка `if (playerData == null)`, которая пишет ошибку в консоль;
  - важно показать ученикам, как читать такие сообщения и находить проблему в Inspector.

- **Перепутаны `PlayerData` и `PlayerStats`**:
  - `PlayerData` — “базовые числа по умолчанию” для разных вариантов игрока;
  - `PlayerStats` — “живые” текущие значения во время игры;
  - важно проговорить: менять баланс → правим `PlayerData`; обрабатывать урон/лечение → работаем через `PlayerStats`.

- **Изменяют состояние не через методы**:
  - прямое присваивание `currentHealth = ...` обходит проверки и события;
  - правильный путь — всегда использовать `TakeDamage`, `Heal`, `AddMana`, чтобы логика была централизована.

## 1. Цели урока

- **Техническая цель**: создать ScriptableObject `PlayerData`, который хранит базовые параметры игрока (здоровье, мана, скорость, сила прыжка и т.д.).
- **Обучающая цель**: показать разделение **данных** и **логики** и познакомить с `ScriptableObject` как формой хранения данных.

После выполнения урока у тебя будет отдельный файл‑данные `PlayerData_Default.asset`, который можно назначать разным префабам игрока.

---

## 2. Что такое PlayerData и зачем он нужен

### 2.1. Проблема без PlayerData

Если все параметры игрока (здоровье, скорость, прыжок и т.п.) хранить прямо в компонентах на `Player`, возникают проблемы:

- При изменении баланса нужно заходить в каждую сцену и каждый префаб.
- Нельзя легко сделать несколько разных “классов” игрока (рыцарь, вор, маг).
- Данные смешиваются с логикой — класс, который что‑то делает, одновременно хранит и “сырые числа”.

### 2.2. Решение: ScriptableObject PlayerData

`PlayerData` будет:

- **ScriptableObject**, то есть отдельный ассет‑файл в проекте.
- Хранить только **данные по умолчанию**:
  - максимальное здоровье;
  - максимальную ману/энергию;
  - базовую скорость движения;
  - силу прыжка;
  - дополнительные параметры (ускорение, скорость поворота и т.д.).

Логика работы с этими данными (урон, лечение, движение) будет находиться в других классах (`PlayerStats`, `PlayerController`).

**Принцип ООП:** разделение ответственности — `PlayerData` отвечает за данные, другие классы — за поведение.

---

## 3. Подготовка папок

1. В Unity открой окно `Project`.
2. Убедись, что у тебя есть папка:
   - `Assets/Scripts/Player/` — для скриптов, связанных с игроком.
3. Создай папку для ScriptableObject игрока:
   - `Assets/ScriptableObjects/Player/`
   - Если папки `ScriptableObjects` или `Player` нет, создай их:
     - ПКМ по `Assets` → `Create` → `Folder` → `ScriptableObjects`
     - ПКМ по `ScriptableObjects` → `Create` → `Folder` → `Player`

---

## 4. Создание скрипта PlayerData

### 4.1. Шаги в Unity

1. В окне `Project` перейди в папку `Assets/Scripts/Player/`.
2. ПКМ → `Create` → `C# Script`.
3. Назови скрипт **`PlayerData`** (точно так же, как имя класса).
4. Дважды кликни по скрипту, чтобы открыть его в редакторе (Visual Studio, Rider, VS Code и т.п.).

### 4.2. Что нужно сделать в коде

Сейчас Unity создала заготовку класса как `MonoBehaviour`. Тебе нужно:

1. Изменить наследование с `MonoBehaviour` на `ScriptableObject`.
2. Добавить атрибут `CreateAssetMenu`, чтобы можно было создавать `PlayerData` через меню `Create`.
3. Добавить **публичные поля** для базовых параметров игрока.

Ниже приведён пример того, что должно получиться. Используй его как ориентир, но набирай код **самостоятельно**, понимая, что ты делаешь.

```csharp
using UnityEngine;

// Атрибут, позволяющий создавать этот ScriptableObject через меню Create
[CreateAssetMenu(
    fileName = "PlayerData",
    menuName = "Game Data/Player Data",
    order = 0)]
public class PlayerData : ScriptableObject
{
    [Header("Основные характеристики")]
    [Min(1f)]
    public float maxHealth = 100f;

    [Min(0f)]
    public float maxMana = 50f;

    [Header("Движение")]
    [Min(0f)]
    public float moveSpeed = 5f;

    [Min(0f)]
    public float jumpForce = 5f;

    [Header("Дополнительные параметры движения")]
    [Min(0f)]
    public float acceleration = 10f;

    [Min(0f)]
    public float rotationSpeed = 720f; // градусов в секунду
}
```

Разбор кода:

- `ScriptableObject` — базовый класс для ассетов‑данных.
- `[CreateAssetMenu]` — появляется пункт в меню **Create → Game Data → Player Data**.
- `[Header]` и `[Min]` — атрибуты только для удобства в Inspector.

---

## 5. Создание экземпляра PlayerData в проекте

Теперь нужно создать **конкретный объект данных** на основе этого класса.

1. В окне `Project` перейди в `Assets/ScriptableObjects/Player/`.
2. ПКМ в пустой области → `Create` → `Game Data` → `Player Data` (название меню зависит от `menuName` в атрибуте).
3. Назови ассет **`PlayerData_Default`**.
4. Выбери `PlayerData_Default` и в Inspector выставь значения:
   - `Max Health` — например, `100`.
   - `Max Mana` — `50` или `0`, если мана пока не используется.
   - `Move Speed` — `5`.
   - `Jump Force` — `5`.
   - `Acceleration` — `10`.
   - `Rotation Speed` — `720`.

Эти значения — стартовые и могут позже изменяться под баланс игры.

---

## 6. Как PlayerData будет использоваться дальше

На следующих уроках:

- `PlayerStats` будет ссылаться на `PlayerData_Default` и в `Awake/Start` брать оттуда стартовые значения (здоровье, мана).
- `PlayerController` будет использовать скорость и другие параметры для расчёта движения.
- `PlayerProgression` сможет изменять максимальные значения при повышении уровня (либо через дополнительные бонусы, либо изменяя данные на лету — это хороший повод поговорить про плюсы/минусы изменения ScriptableObject во время игры).

Важно: сам `PlayerData` **не знает**, как использовать эти числа. Он только их хранит.

---

## 7. Мини‑проверка

1. Убедись, что:
   - Класс `PlayerData` наследуется от `ScriptableObject`, а не от `MonoBehaviour`.
   - В проекте есть ассет `PlayerData_Default` в `Assets/ScriptableObjects/Player/`.
2. Попробуй:
   - Поменять `maxHealth` в `PlayerData_Default`.
   - Запомнить, что позже (когда подключим `PlayerStats`) изменение этого числа будет менять стартовое здоровье игрока во всех сценах, где используется этот `PlayerData`.

Если всё это готово — можно переходить к уроку 5.2 (`PlayerStats`).

