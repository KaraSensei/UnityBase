# Этап 2: Ядро игры (Core Systems)

## Цель этапа
Собрать “скелет” проекта: **инициализация**, **управление состояниями игры**, **переключение сцен**, **центральные события**.  
После этого этапа вы сможете запускать игру с `Bootstrap` и уверенно управлять: “меню → игра → пауза → меню”.

> Важно: на этом этапе мы делаем **минимально рабочую основу**, а не “идеальную архитектуру”. Для обучения это критично.

---

## Что должно получиться в конце этапа (чек-лист)

- [ ] В **Build Settings** сцены стоят в порядке: `Bootstrap` (0) → `MainMenu` (1) → `GameScene` (2)
- [ ] В `Bootstrap` есть объект `BootstrapManager` и скрипт, который **создает/инициализирует менеджеры** и грузит `MainMenu`
- [ ] В проекте есть **GameManager** (Singleton-подобный) с состояниями игры: `Menu`, `Playing`, `Paused`
- [ ] Есть **SceneLoader** (или `SceneService`) для загрузки сцен по имени
- [ ] Есть **EventBus** (простая система событий), чтобы разные системы могли общаться без прямых ссылок
- [ ] В `MainMenu` кнопка “Новая игра” загружает `GameScene`
- [ ] В `GameScene` кнопка “В меню” возвращает в `MainMenu`
- [ ] Нажатие `Esc` (временно можно через старый Input) открывает/закрывает паузу и меняет состояние игры

---

## Рекомендуемая структура файлов (только для ориентира)

Создавайте скрипты в `Assets/Scripts/Core/`:
- `BootstrapManager.cs`
- `GameManager.cs`
- `SceneLoader.cs`
- `EventBus.cs`
- (опционально) `App.cs` или `ServiceRegistry.cs` — если хотите отдельный объект под “сервисы”. Как это делать и использовать DI контейнеры не будет освещено сейчас, но если кто-то уже знает -- можно делать. Если хотите повысить квалификацию -- можете найти в интернете и добавить себе. 

> Если делаете 2D/другой жанр — Core обычно одинаковый, меняется только содержимое `GameScene`.

---

## Урок 2.1: Bootstrap — точка входа и порядок инициализации

### Идея
**Bootstrap-сцена** запускается первой и:
1) создает менеджеры (которые живут между сценами),  
2) подготавливает “проектные сервисы”,  
3) переводит игру в меню.

### В Unity (шаги)
1. Откройте сцену `Bootstrap`.
2. В Hierarchy создайте пустой объект `BootstrapManager`.
3. Создайте скрипт `BootstrapManager.cs` и добавьте на объект.
4. В `Build Settings` убедитесь, что `Bootstrap` стоит **первой**.

### Что должен делать `BootstrapManager` (логика)
- В `Awake()` (или `Start()`):
  - проверить, что второй раз не создается (защита от дублей)
  - создать/поднять менеджеры:
    - `GameManager`
    - `SceneLoader`
    - `EventBus`
    - (позже добавятся: SettingsManager, AudioManager, InputManager…)
  - сделать их `DontDestroyOnLoad`
  - загрузить `MainMenu`

### Пример кода `BootstrapManager` 
Ниже — **полный пример**, который можно почти без изменений вставлять в проект.

```csharp
using UnityEngine;

public class BootstrapManager : MonoBehaviour
{
    // Защита от повторной инициализации, если Bootstrap загрузится повторно
    private static bool _initialized;

    private void Awake()
    {
        // Защита от дублей, если вдруг Bootstrap окажется в сцене дважды
        if (_initialized)
        {
            Destroy(gameObject);
            return;
        }

        _initialized = true;
        DontDestroyOnLoad(gameObject);

        // Создаём/поднимаем основные менеджеры
        CreateGameManager();
        CreateSceneLoader();
        CreateEventBus();

        // Загружаем главное меню
        SceneLoader.Instance.Load(SceneNames.MainMenu);
    }

    private static void CreateGameManager()
    {
        GameManager existing = FindFirstObjectByType<GameManager>();
        if (existing != null)
        {
            DontDestroyOnLoad(existing.gameObject);
            return;
        }

        GameObject go = new GameObject("GameManager");
        go.AddComponent<GameManager>();
        DontDestroyOnLoad(go);
    }

    private static void CreateSceneLoader()
    {
        SceneLoader existing = FindFirstObjectByType<SceneLoader>();
        if (existing != null)
        {
            DontDestroyOnLoad(existing.gameObject);
            return;
        }

        GameObject go = new GameObject("SceneLoader");
        go.AddComponent<SceneLoader>();
        DontDestroyOnLoad(go);
    }

    private static void CreateEventBus()
    {
        EventBus existing = FindFirstObjectByType<EventBus>();
        if (existing != null)
        {
            DontDestroyOnLoad(existing.gameObject);
            return;
        }

        GameObject go = new GameObject("EventBus");
        go.AddComponent<EventBus>();
        DontDestroyOnLoad(go);
    }
}
```

Дополнительно удобно завести простой класс с именами сцен:

```csharp
public static class SceneNames
{
    public const string Bootstrap = "Bootstrap";
    public const string MainMenu = "MainMenu";
    public const string GameScene = "GameScene";
}
```

### Объяснение: Зачем нужен `SceneNames`?

**Проблема без `SceneNames`:**
```csharp
// Плохо: если опечатка, игра сломается, и ошибку заметишь только при запуске
SceneManager.LoadScene("MainMen"); // опечатка!
```

**Решение с `SceneNames`:**
```csharp
// Хорошо: если опечатка, код не скомпилируется - ошибку увидишь сразу
SceneManager.LoadScene(SceneNames.MainMen); // ошибка компиляции!
SceneManager.LoadScene(SceneNames.MainMenu); // правильно
```

**Преимущества:**
- ✅ Защита от опечаток (ошибка видна сразу при написании кода)
- ✅ Автодополнение в редакторе (IDE подскажет доступные сцены)
- ✅ Легко переименовать сцену (меняешь в одном месте)
- ✅ Понятный код (`SceneNames.MainMenu` читается лучше, чем `"MainMenu"`)

---

### Объяснение: Что такое `static class`?

**Обычный класс** — нужно создавать объект (экземпляр):
```csharp
public class Player
{
    public string name;
}

// Использование:
Player player1 = new Player(); // создали объект
player1.name = "Игрок 1";
Player player2 = new Player(); // создали еще один объект
player2.name = "Игрок 2";
```

**Статический класс** — объект создавать нельзя, используется напрямую:
```csharp
public static class SceneNames
{
    public const string MainMenu = "MainMenu";
}

// Использование:
// НЕЛЬЗЯ: SceneNames names = new SceneNames(); // ❌ ошибка!
// НУЖНО: SceneNames.MainMenu // ✅ правильно
```

**Отличия:**

| Обычный класс | Статический класс |
|---------------|-------------------|
| Можно создать много объектов | Объекты создавать нельзя |
| `Player player = new Player();` | `SceneNames.MainMenu` (без `new`) |
| Каждый объект хранит свои данные | Один набор данных на всю программу |
| Подходит для игроков, врагов, предметов | Подходит для утилит, констант, помощников |

**Когда использовать `static class`:**
- Когда нужны только константы (как `SceneNames`)
- Когда нужны вспомогательные методы, которые не хранят состояние
- Когда не нужны объекты (например, `Math.PI`, `Math.Sqrt()`)

---

### Объяснение: Что такое `const` переменные?

**Обычная переменная** — можно менять:
```csharp
public class GameManager : MonoBehaviour
{
    public string currentScene = "MainMenu"; // обычная переменная
    
    void Start()
    {
        currentScene = "GameScene"; // ✅ можно изменить
        currentScene = "Bootstrap"; // ✅ можно изменить снова
    }
}
```

**Константа (`const`)** — нельзя менять после создания:
```csharp
public static class SceneNames
{
    public const string MainMenu = "MainMenu"; // константа
    
    // В методе:
    // MainMenu = "ДругоеМеню"; // ❌ ОШИБКА! Константу менять нельзя
}
```

**Отличия:**

| Обычная переменная | Константа (`const`) |
|-------------------|---------------------|
| Можно менять значение | Значение задается один раз и навсегда |
| `string name = "А"; name = "Б";` ✅ | `const string name = "А"; name = "Б";` ❌ |
| Значение может быть разным в разное время | Значение всегда одно и то же |
| Подходит для: текущее здоровье, счет | Подходит для: имена сцен, настройки по умолчанию |

**Почему `const` для имен сцен?**
- Имена сцен не должны меняться во время работы программы
- Это защита от случайных ошибок
- Компилятор может оптимизировать код с константами

**Пример использования:**
```csharp
// Вместо:
SceneManager.LoadScene("MainMenu"); // строка - можно опечататься

// Используем:
SceneManager.LoadScene(SceneNames.MainMenu); // константа - безопасно
```

---

### Проверка
А никак вы не проверите, потому что надо еще написать недостающие скрипты, но как это должно быдет работать, когда мы их напишем:
- Запускаете Play → через секунду оказываетесь в `MainMenu`
- В сцене `MainMenu` в Hierarchy (в Play Mode) видите объекты менеджеров с отметкой `DontDestroyOnLoad`

### Частые ошибки
- **Bootstrap не первая сцена** → менеджеры не создаются.
- **Менеджеры создаются и в Bootstrap, и в сценах** → появляются дубли.

---

## Урок 2.2: GameManager — состояния игры (Menu/Playing/Paused)

### Зачем
Чтобы в проекте была “правда в одном месте”: сейчас мы в меню? играем? на паузе?

### Требования к `GameManager`
- Singleton-подобный доступ (например, `GameManager.Instance`)
- Хранит текущее состояние:
  - `Menu`
  - `Playing`
  - `Paused`
- Методы:
  - `StartGame()` → ставит `Playing`, грузит `GameScene`
  - `GoToMenu()` → ставит `Menu`, грузит `MainMenu`
  - `Pause()` / `Resume()` → переключает паузу

### Пауза (важное для учеников)
Есть два основных подхода:

- **Простой (подходит большинству учебных проектов)**:
  - `Time.timeScale = 0` на паузе
  - `Time.timeScale = 1` при продолжении
  - UI продолжает работать (если EventSystem есть)

- **Более гибкий**:
  - не менять `timeScale`, а отключать управление/AI/анимации вручную
  - полезно для онлайн-игр и сложных систем

Для обучения выбирайте **первый**.

### Пример кода `GameManager`

```csharp
using UnityEngine;

public enum GameState
{
    Menu,
    Playing,
    Paused
}

public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }

    public GameState CurrentState { get; private set; } = GameState.Menu;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void StartGame()
    {
        CurrentState = GameState.Playing;
        Time.timeScale = 1f;
        SceneLoader.Instance.Load(SceneNames.GameScene);
        Debug.Log("Game started");
    }

    public void GoToMenu()
    {
        CurrentState = GameState.Menu;
        Time.timeScale = 1f;
        SceneLoader.Instance.Load(SceneNames.MainMenu);
        Debug.Log("Go to Main Menu");
    }

    public void Pause()
    {
        if (CurrentState != GameState.Playing)
            return;

        CurrentState = GameState.Paused;
        Time.timeScale = 0f; // простой вариант паузы
        EventBus.Instance.RaiseGamePaused();
        Debug.Log("Game paused");
    }

    public void Resume()
    {
        if (CurrentState != GameState.Paused)
            return;

        CurrentState = GameState.Playing;
        Time.timeScale = 1f;
        EventBus.Instance.RaiseGameResumed();
        Debug.Log("Game resumed");
    }
}
```

---

### Объяснение: Что такое `enum` (перечисление)?

**Enum** — это способ создать список именованных констант (вариантов выбора).

**Проблема без `enum`:**
```csharp
// Плохо: можно написать любое число, даже неправильное
int state = 0; // что это значит?
int state = 5; // такого состояния нет!
int state = -1; // ошибка!
```

**Решение с `enum`:**
```csharp
// Хорошо: можно выбрать только из списка
GameState state = GameState.Menu; // ✅ понятно
GameState state = GameState.Playing; // ✅ правильно
// GameState state = GameState.WrongState; // ❌ ошибка компиляции!
```

**Как работает `enum`:**
```csharp
public enum GameState
{
    Menu,      // автоматически = 0
    Playing,   // автоматически = 1
    Paused    // автоматически = 2
}

// Использование:
GameState current = GameState.Menu;
if (current == GameState.Playing)
{
    // игра идет
}
```

**Преимущества:**
- ✅ Понятные имена вместо чисел
- ✅ Защита от ошибок (нельзя использовать несуществующее значение)
- ✅ Автодополнение в редакторе

**Аналогия:** Как меню в кафе — можно выбрать только то, что есть в списке, а не придумывать блюда.

---

### Объяснение: Что такое Singleton (одиночка)?

**Проблема:** Нужен один `GameManager` на всю игру, но что если создать два?

**Без Singleton:**
```csharp
// В сцене MainMenu:
GameManager manager1 = new GameManager();

// В сцене GameScene:
GameManager manager2 = new GameManager(); // ❌ теперь два менеджера!

// Который правильный? Какой использовать?
```

**С Singleton:**
```csharp
// Всегда один и тот же объект
GameManager.Instance.StartGame(); // ✅ всегда работает
GameManager.Instance.Pause();     // ✅ всегда тот же менеджер
```

**Как работает Singleton в коде:**

```csharp
public class GameManager : MonoBehaviour
{
    // Статическая переменная - одна на всю программу
    public static GameManager Instance { get; private set; }

    private void Awake()
    {
        // Если Instance уже существует (не null) и это не мы
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject); // уничтожаем дубликат
            return; // выходим из метода
        }

        // Если Instance пустой, значит мы первый
        Instance = this; // запоминаем себя как единственный экземпляр
        DontDestroyOnLoad(gameObject); // не уничтожать при смене сцены
    }
}
```

**Как это работает пошагово:**

1. **Первый раз** (в Bootstrap):
   - `Instance` = `null` (пусто)
   - Проверка `if (Instance != null)` → `false`, пропускаем
   - `Instance = this` → сохраняем себя
   - Менеджер живет дальше

2. **Второй раз** (если попытались создать еще один):
   - `Instance` уже не `null` (там первый менеджер)
   - Проверка `if (Instance != null && Instance != this)` → `true`
   - `Destroy(gameObject)` → уничтожаем дубликат
   - `return` → выходим, не продолжаем

**Использование:**
```csharp
// В любом месте кода:
GameManager.Instance.StartGame(); // обращаемся к единственному экземпляру
GameManager.Instance.Pause();
```

**Аналогия:** Как директор школы — может быть только один директор, а не десять.

---

### Объяснение: Что такое свойства (Properties) — `get` и `set`?

**Обычная переменная:**
```csharp
public int health = 100; // можно читать И менять откуда угодно

// В другом скрипте:
player.health = -50; // ❌ можно установить отрицательное!
player.health = 9999; // ❌ можно установить слишком большое!
```

**Свойство с `get` и `set`:**
```csharp
private int _health = 100; // приватная переменная (скрыта)

// Свойство - контролируемый доступ
public int Health 
{ 
    get { return _health; }        // читать можно
    set { _health = value; }       // менять можно
}
```

**Свойство с `private set` (только чтение снаружи):**
```csharp
public GameState CurrentState { get; private set; } = GameState.Menu;

// Что это значит:
// ✅ get - можно читать: GameManager.Instance.CurrentState
// ❌ set - нельзя менять снаружи (только внутри класса)
```

**Пример использования:**

```csharp
// В GameManager:
public GameState CurrentState { get; private set; } = GameState.Menu;

// Внутри GameManager можно менять:
CurrentState = GameState.Playing; // ✅ работает

// В другом скрипте:
GameManager.Instance.CurrentState = GameState.Paused; // ❌ ОШИБКА!
// Можно только читать:
GameState state = GameManager.Instance.CurrentState; // ✅ работает
```

**Зачем `private set`?**
- Защита от случайных изменений извне
- Менять состояние можно только через методы (`StartGame()`, `Pause()`)
- Гарантия, что состояние всегда корректное

**Аналогия:** Как счетчик в банке — смотреть баланс можно, но менять только через операции (пополнение/снятие), а не напрямую.

---

### Объяснение: Что такое `static`?

**Обычная переменная** — у каждого объекта своя:
```csharp
public class Player
{
    public string name; // у каждого игрока свое имя
}

Player player1 = new Player();
player1.name = "Анна";

Player player2 = new Player();
player2.name = "Борис"; // разные имена
```

**Статическая переменная** — одна на всю программу:
```csharp
public class GameManager : MonoBehaviour
{
    public static GameManager Instance; // ОДИН на всю программу
}

// Использование:
GameManager.Instance.StartGame(); // обращаемся БЕЗ создания объекта
// НЕ нужно: GameManager gm = new GameManager();
```

**Отличия:**

| Обычная переменная | Статическая переменная |
|-------------------|------------------------|
| `public int health;` | `public static int score;` |
| У каждого объекта своя | Одна на всю программу |
| `player.health` | `GameManager.Instance` |
| Нужен объект | Не нужен объект |

**Когда использовать `static`:**
- Когда нужен один экземпляр на всю программу (Singleton)
- Когда данные общие для всех (например, общий счет)
- Когда не нужны объекты (утилиты, константы)

---

### Объяснение: Что такое `DontDestroyOnLoad`?

**Проблема:** При загрузке новой сцены Unity уничтожает все объекты старой сцены.

**Без `DontDestroyOnLoad`:**
```csharp
// В сцене MainMenu:
GameManager manager = ...; // создали менеджер

// Загрузили GameScene:
// ❌ GameManager уничтожен! Теперь его нет!
```

**С `DontDestroyOnLoad`:**
```csharp
DontDestroyOnLoad(gameObject); // "не уничтожай этот объект при смене сцены"

// Загрузили GameScene:
// ✅ GameManager все еще существует!
```

**Как работает:**
- Обычные объекты → уничтожаются при смене сцены
- Объекты с `DontDestroyOnLoad` → остаются жить между сценами

**Зачем это нужно:**
- `GameManager` должен жить во всех сценах
- `SceneLoader` нужен для переключения сцен
- `EventBus` должен работать везде

**Аналогия:** Как паспорт — он остается с тобой, даже когда переезжаешь в другой город.

---

### Объяснение: `Awake()` vs `Start()` — в чем разница?

**Порядок вызова в Unity:**

1. **`Awake()`** — вызывается **первым**, когда объект создается
   - Вызывается даже если объект неактивен
   - Используется для инициализации, настройки ссылок
   - Все `Awake()` вызываются до всех `Start()`

2. **`Start()`** — вызывается **после** всех `Awake()`
   - Вызывается только если объект активен
   - Используется для логики, которая зависит от других объектов

**Пример:**

```csharp
public class GameManager : MonoBehaviour
{
    private void Awake()
    {
        // ✅ Здесь инициализация Singleton
        // ✅ Здесь DontDestroyOnLoad
        // ✅ Здесь создание других менеджеров
        // Все это должно произойти ДО того, как другие объекты начнут работать
    }

    private void Start()
    {
        // ✅ Здесь можно использовать другие менеджеры
        // ✅ Здесь можно обращаться к GameManager.Instance из других скриптов
        // Потому что в Awake() все уже создано
    }
}
```

**Почему `Awake()` для Singleton?**
- Нужно установить `Instance` **до** того, как другие объекты попытаются его использовать
- `Awake()` гарантированно вызовется первым

**Правило:** Инициализация → `Awake()`, логика → `Start()`.

---

### Объяснение: Что такое `Time.timeScale`?

**`Time.timeScale`** — это "скорость времени" в игре.

**Значения:**
- `Time.timeScale = 1f` → нормальная скорость (1x)
- `Time.timeScale = 0.5f` → медленнее в 2 раза (0.5x)
- `Time.timeScale = 0f` → время остановлено (пауза)
- `Time.timeScale = 2f` → быстрее в 2 раза (2x)

**Что влияет:**
- ✅ Физика (Rigidbody)
- ✅ Анимации
- ✅ `Time.deltaTime`
- ❌ UI (продолжает работать)
- ❌ `Time.realtimeSinceStartup` (реальное время)

**Пример использования:**

```csharp
public void Pause()
{
    Time.timeScale = 0f; // останавливаем время
    // Теперь:
    // - Персонаж замер
    // - Враги замерли
    // - Анимации остановились
    // - UI продолжает работать (можно нажать кнопку)
}

public void Resume()
{
    Time.timeScale = 1f; // возобновляем нормальную скорость
    // Все снова работает
}
```

**Аналогия:** Как кнопка паузы на видео — останавливает воспроизведение, но интерфейс (кнопки) продолжает работать.

---

### Объяснение: Что такое `return` в методе?

**`return`** — выход из метода (прекращение выполнения).

**Без `return`:**
```csharp
public void Pause()
{
    if (CurrentState != GameState.Playing)
    {
        // что-то сделать, но метод продолжит выполняться
    }
    
    CurrentState = GameState.Paused; // ❌ выполнится даже если состояние неправильное!
}
```

**С `return`:**
```csharp
public void Pause()
{
    if (CurrentState != GameState.Playing)
        return; // ✅ выходим из метода, дальше не выполняем
    
    // Этот код выполнится ТОЛЬКО если состояние = Playing
    CurrentState = GameState.Paused;
    Time.timeScale = 0f;
}
```

**Зачем это нужно:**
- **Защита от ошибок** — не выполняем код, если условия не выполнены
- **Ранний выход** — если что-то не так, сразу выходим

**Пример пошагово:**

```csharp
public void Pause()
{
    // Шаг 1: Проверяем состояние
    if (CurrentState != GameState.Playing)
        return; // Если НЕ Playing → выходим, дальше не идем
    
    // Шаг 2: Этот код выполнится ТОЛЬКО если состояние = Playing
    CurrentState = GameState.Paused;
    Time.timeScale = 0f;
    Debug.Log("Game paused");
}
```

**Сценарий 1:** `CurrentState = GameState.Menu`
- Проверка: `Menu != Playing` → `true`
- `return` → выходим
- Код ниже не выполняется ✅

**Сценарий 2:** `CurrentState = GameState.Playing`
- Проверка: `Playing != Playing` → `false`
- Пропускаем `return`
- Выполняем код ниже ✅

**Аналогия:** Как проверка билета — если билета нет, не пускаем дальше (`return`), если есть — пропускаем.

---

### Проверка
Все еще никак не проверим, потому что не дописали, но: 
- В консоли (Debug.Log) видно смену состояния при нажатии `Esc`
- В паузе персонаж/физика “замерли” (если вы используете timeScale)

---

## Урок 2.3: SceneLoader — единая точка загрузки сцен

### Зачем
Чтобы не разбрасывать `SceneManager.LoadScene(...)` по всему проекту.

### Требования к `SceneLoader`
- Метод `Load(string sceneName)`
- (опционально) корутина для загрузки асинхронно `LoadAsync`
- Логи в консоль при загрузке (полезно для обучения)

### Советы для учеников
- Сцены лучше грузить **по имени**, но:
  - имя сцены должно быть **в Build Settings**
  - имя должно совпадать с файлом `.unity`
- Хорошая практика: завести класс `SceneNames` с константами (см. подробное объяснение в разделе **Урок 2.1** выше):
  - `public const string Bootstrap = "Bootstrap";` и т.д.
  - Это защищает от опечаток и делает код понятнее

### Пример кода `SceneLoader`

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;

public class SceneLoader : MonoBehaviour
{
    public static SceneLoader Instance { get; private set; }

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    public void Load(string sceneName)
    {
        Debug.Log($"Loading scene: {sceneName}");
        SceneManager.LoadScene(sceneName);
    }

    // Пример асинхронной загрузки (можно использовать позже)
    public void LoadAsync(string sceneName)
    {
        StartCoroutine(LoadSceneAsyncCoroutine(sceneName));
    }

    private IEnumerator LoadSceneAsyncCoroutine(string sceneName)
    {
        AsyncOperation operation = SceneManager.LoadSceneAsync(sceneName);

        while (!operation.isDone)
        {
            // Здесь можно обновлять прогрессбар
            Debug.Log($"Loading progress: {operation.progress}");
            yield return null;
        }

        Debug.Log("Scene loaded");
    }
}
```

---

### Объяснение: Что такое `SceneManager.LoadScene`?

**`SceneManager.LoadScene`** — это встроенный метод Unity для загрузки сцен.

**Как работает:**
```csharp
SceneManager.LoadScene("MainMenu"); // загружает сцену по имени
```

**Что происходит:**
1. Unity находит сцену с таким именем
2. Выгружает текущую сцену (уничтожает все объекты)
3. Загружает новую сцену
4. Игра продолжается в новой сцене

**Важно:**
- Сцена **должна быть** в Build Settings
- Имя сцены должно **точно совпадать** с именем файла (без `.unity`)
- Загрузка происходит **мгновенно** (игра "зависает" на момент загрузки)

**Проблема синхронной загрузки:**
```csharp
// Плохо: игра "зависает" на время загрузки
SceneManager.LoadScene("GameScene"); 
// Игрок видит черный экран, не может понять, что происходит
```

**Решение — асинхронная загрузка:**
```csharp
// Хорошо: загрузка происходит постепенно, можно показать прогресс
SceneLoader.Instance.LoadAsync("GameScene");
// Можно показать прогрессбар, игрок видит, что игра работает
```

**Аналогия:** 
- Синхронная загрузка = резко переключить канал на ТВ (мгновенно, но может "моргнуть")
- Асинхронная загрузка = плавно переключить канал (плавно, с анимацией)

---

### Объяснение: Что такое корутины (Coroutines)?

**Корутина** — это метод, который может "приостановиться" и продолжить выполнение позже.

**Обычный метод:**
```csharp
public void DoSomething()
{
    Debug.Log("Шаг 1");
    Debug.Log("Шаг 2");
    Debug.Log("Шаг 3");
    // Все выполняется сразу, за один кадр
}
```

**Корутина:**
```csharp
public IEnumerator DoSomething()
{
    Debug.Log("Шаг 1");
    yield return null; // приостановиться на 1 кадр
    
    Debug.Log("Шаг 2");
    yield return new WaitForSeconds(1f); // приостановиться на 1 секунду
    
    Debug.Log("Шаг 3");
    // Выполняется постепенно, не блокируя игру
}
```

**Как это работает:**
- `IEnumerator` — тип возвращаемого значения (интерфейс для итератора)
- `yield return null` — "подожди один кадр, потом продолжай"
- `yield return new WaitForSeconds(1f)` — "подожди 1 секунду, потом продолжай"
- `StartCoroutine(...)` — запускает корутину

**Пример в SceneLoader:**
```csharp
private IEnumerator LoadSceneAsyncCoroutine(string sceneName)
{
    // Начинаем загрузку
    AsyncOperation operation = SceneManager.LoadSceneAsync(sceneName);
    
    // Пока загрузка не завершена
    while (!operation.isDone)
    {
        // Каждый кадр проверяем прогресс
        Debug.Log($"Loading progress: {operation.progress}");
        yield return null; // ждем следующий кадр
    }
    
    // Загрузка завершена
    Debug.Log("Scene loaded");
}
```

**Зачем это нужно:**
- ✅ Игра не "зависает" во время загрузки
- ✅ Можно показывать прогрессбар
- ✅ Можно показывать анимацию загрузки
- ✅ Игрок видит, что игра работает

**Аналогия:** Как загрузка файла — видно прогресс, можно отменить, игра не зависает.

---

### Объяснение: Что такое `AsyncOperation`?

**`AsyncOperation`** — это объект, который представляет асинхронную операцию (загрузку сцены).

**Свойства `AsyncOperation`:**
- `isDone` — `true`, когда загрузка завершена, `false` — еще идет
- `progress` — прогресс от 0.0 до 1.0 (0% до 100%)

**Пример использования:**
```csharp
AsyncOperation operation = SceneManager.LoadSceneAsync("GameScene");

// Проверяем, завершена ли загрузка
if (operation.isDone)
{
    Debug.Log("Загрузка завершена!");
}

// Смотрим прогресс
float percent = operation.progress * 100f; // 0.9 = 90%
Debug.Log($"Загружено: {percent}%");
```

**В цикле:**
```csharp
while (!operation.isDone) // пока НЕ завершено
{
    // Загрузка еще идет
    Debug.Log($"Прогресс: {operation.progress}");
    yield return null; // ждем следующий кадр
}
// Когда вышли из цикла, значит operation.isDone == true
```

**Аналогия:** Как загрузка видео на YouTube — видно процент, можно отслеживать прогресс.

---

### Объяснение: Что такое `yield return null`?

**`yield return null`** — это команда "подожди один кадр, потом продолжай".

**Как это работает:**
```csharp
private IEnumerator Example()
{
    Debug.Log("Кадр 1");
    yield return null; // приостановиться, ждем следующего кадра
    
    Debug.Log("Кадр 2");
    yield return null; // приостановиться, ждем следующего кадра
    
    Debug.Log("Кадр 3");
}
```

**Что происходит:**
1. Выполняется `Debug.Log("Кадр 1")`
2. `yield return null` → Unity говорит: "Ок, подожду до следующего кадра"
3. Unity отрисовывает кадр, обрабатывает ввод
4. Возвращается к корутине, выполняет `Debug.Log("Кадр 2")`
5. И так далее...

**Зачем это нужно в загрузке сцен:**
```csharp
while (!operation.isDone)
{
    Debug.Log($"Progress: {operation.progress}");
    yield return null; // ждем кадр, чтобы проверить прогресс снова
}
```

**Без `yield return null`:**
```csharp
// Плохо: цикл выполнится миллион раз за один кадр
while (!operation.isDone)
{
    Debug.Log($"Progress: {operation.progress}");
    // Нет yield → цикл крутится бесконечно, игра зависает!
}
```

**С `yield return null`:**
```csharp
// Хорошо: проверяем прогресс каждый кадр
while (!operation.isDone)
{
    Debug.Log($"Progress: {operation.progress}");
    yield return null; // ждем кадр, игра не зависает
}
```

**Аналогия:** Как проверка почты — не нужно проверять каждую секунду, достаточно раз в день (`yield return null` = раз в кадр).

---

### Объяснение: Что такое строковая интерполяция (`$"..."`)?

**Строковая интерполяция** — способ вставить переменные в строку.

**Без интерполяции (старый способ):**
```csharp
string sceneName = "MainMenu";
string message = "Loading scene: " + sceneName; // сложение строк
Debug.Log(message);
```

**С интерполяцией (новый способ):**
```csharp
string sceneName = "MainMenu";
Debug.Log($"Loading scene: {sceneName}"); // вставляем переменную в строку
```

**Как работает:**
- `$` перед строкой — включает интерполяцию
- `{переменная}` — место, куда вставится значение переменной

**Примеры:**
```csharp
string name = "Иван";
int age = 15;

// Можно вставлять переменные
Debug.Log($"Имя: {name}, Возраст: {age}"); 
// Выведет: "Имя: Иван, Возраст: 15"

// Можно вычислять выражения
Debug.Log($"Через год будет: {age + 1}"); 
// Выведет: "Через год будет: 16"

// Можно вызывать методы
Debug.Log($"Прогресс: {operation.progress * 100}%"); 
// Выведет: "Прогресс: 75%"
```

**В SceneLoader:**
```csharp
Debug.Log($"Loading scene: {sceneName}");
// Если sceneName = "MainMenu", выведет: "Loading scene: MainMenu"
```

**Преимущества:**
- ✅ Код короче и понятнее
- ✅ Легче читать
- ✅ Можно вставлять выражения

**Аналогия:** Как заполнение бланка — вместо "Имя: " + имя, просто пишешь `{имя}` в нужном месте.

---

### Объяснение: Зачем нужен отдельный `SceneLoader`?

**Проблема без `SceneLoader`:**
```csharp
// В MainMenu:
SceneManager.LoadScene("GameScene");

// В GameScene:
SceneManager.LoadScene("MainMenu");

// В Settings:
SceneManager.LoadScene("MainMenu");

// Проблемы:
// ❌ Если переименуешь сцену, нужно менять везде
// ❌ Можно опечататься в имени сцены
// ❌ Нет единого места для логики загрузки
```

**Решение с `SceneLoader`:**
```csharp
// Везде используем один метод:
SceneLoader.Instance.Load(SceneNames.GameScene);

// Преимущества:
// ✅ Одно место для логики загрузки
// ✅ Легко добавить логирование
// ✅ Легко добавить асинхронную загрузку
// ✅ Защита от опечаток через SceneNames
```

**Что можно добавить в `SceneLoader` позже:**
- Логирование всех загрузок
- Анимация загрузки
- Проверка существования сцены
- Сохранение данных перед загрузкой

**Аналогия:** Как единая служба доставки — вместо того, чтобы каждый магазин сам доставлял товары, есть одна служба, которая делает это правильно.

---

### Объяснение: Синхронная vs Асинхронная загрузка

**Синхронная загрузка** (`Load`):
```csharp
public void Load(string sceneName)
{
    SceneManager.LoadScene(sceneName); // загружает сразу, игра "зависает"
}
```

**Что происходит:**
1. Вызывается `Load("GameScene")`
2. Игра останавливается
3. Выгружается текущая сцена
4. Загружается новая сцена
5. Игра продолжается

**Плюсы:**
- ✅ Просто использовать
- ✅ Мгновенная загрузка

**Минусы:**
- ❌ Игра "зависает" на время загрузки
- ❌ Нет возможности показать прогресс
- ❌ Игрок видит черный экран

---

**Асинхронная загрузка** (`LoadAsync`):
```csharp
public void LoadAsync(string sceneName)
{
    StartCoroutine(LoadSceneAsyncCoroutine(sceneName)); // загружает постепенно
}
```

**Что происходит:**
1. Вызывается `LoadAsync("GameScene")`
2. Начинается загрузка в фоне
3. Игра продолжает работать
4. Можно показывать прогрессбар
5. Когда загрузка завершена, сцена переключается

**Плюсы:**
- ✅ Игра не "зависает"
- ✅ Можно показать прогрессбар
- ✅ Можно показать анимацию загрузки
- ✅ Лучший пользовательский опыт

**Минусы:**
- ❌ Сложнее реализовать
- ❌ Нужно управлять состоянием загрузки

**Когда использовать:**
- **Синхронная** — для быстрых переходов (меню → меню)
- **Асинхронная** — для больших сцен (меню → игровой уровень)

---

### Проверка
- Метод `Load()` загружает сцену мгновенно
- Метод `LoadAsync()` загружает сцену постепенно (можно использовать позже)
- В консоли видны логи при загрузке сцен

---

## Урок 2.4: EventBus — простая система событий

### Зачем
Чтобы системы не держали прямые ссылки друг на друга.

Примеры:
- `PlayerDied` → UI показывает экран смерти
- `QuestCompleted` → выдать награду + обновить журнал квестов
- `SettingsChanged` → применить громкость/разрешение

### Самый простой формат для обучения
Сделайте несколько событий “на первые этапы”:
- `OnGamePaused`
- `OnGameResumed`

**Важно для обучения:** показывайте, что:
- подписка на событие происходит в `OnEnable()`
- отписка происходит в `OnDisable()`

Это убирает “призрачные подписки” и утечки.

---

## Урок 2.5: Связь UI ↔ Core (минимум)

### MainMenu
На кнопках:
- “Новая игра” → `GameManager.StartGame()`
- “Выход” → `Application.Quit()` (в редакторе не сработает)

### GameScene
В `PausePanel` (или временно на кнопке):
- “Продолжить” → `GameManager.Resume()`
- “Главное меню” → `GameManager.GoToMenu()`

> Сейчас можно подключить кнопки напрямую через Inspector (UnityEvent). Это проще и наглядно.

---

## Проверочный сценарий (обязательно прогнать)
1. Запустить Play → автоматически попали в `MainMenu`
2. Нажать “Новая игра” → загрузилась `GameScene`
3. Нажать `Esc` → пауза открылась, timeScale = 0 (если используете)
4. Нажать “Продолжить” → пауза закрылась
5. Нажать “Главное меню” → вернулись в `MainMenu`
6. Остановить Play → убедиться, что нет ошибок/исключений

---

## Частые ошибки 

- **Дубли менеджеров**
  - Причина: создают менеджер в каждой сцене
  - Решение: создавать в Bootstrap и делать `DontDestroyOnLoad`, плюс защита от дублей в `Awake()`

- **Сцена не грузится**
  - Причина: сцена не добавлена в Build Settings или имя написано с ошибкой
  - Решение: добавить сцену в Build Settings, проверить строку имени

- **UI кнопки не кликаются**
  - Причина: нет `EventSystem` или Canvas не настроен
  - Решение: добавить `EventSystem`, проверить `Graphic Raycaster` на Canvas

- **Пауза ломает UI**
  - Причина: выключили EventSystem или Canvas вместо скрытия панели
  - Решение: скрывайте/показывайте панели, а не удаляйте систему UI

---

## Вариации для других жанров / 2D

### 2D
Core тот же. Отличается:
- камера обычно Orthographic
- `GameScene` объекты другие

### Игра без меню
Если у ученика “просто уровень”:
- Bootstrap может грузить сразу `GameScene`
- состояние `Menu` можно не использовать (или оставить на будущее)

### Несколько уровней
Добавьте список сцен уровней и метод:
- `LoadNextLevel()`

---

## Что дальше 
После того как Core работает и сцены переключаются без ошибок, переходите к:
- Input System (новый ввод)
- Затем Cinemachine (камера)

