# Урок 6.2: WeaponBase — базовый класс оружия и наследование

---

## 0. Теория: наследование и полиморфизм на примере оружия

На Этапе 5 мы уже говорили о наследовании в теории (`PlayerData`, `PlayerStats`, `PlayerProgression`) и затрагивали SOLID. В Этапе 6 мы применяем эти идеи на практике в системе оружия.

### 0.1. Что такое наследование в ООП

- **Наследование** — это механизм, который позволяет создать новый класс на основе существующего:
  - дочерний класс **получает** поля и методы базового;
  - может **добавлять** новые поля и методы;
  - может **изменять** (переопределять) поведение базовых методов.

В нашем случае:

- `WeaponBase` — **базовый класс** для всего оружия.
- `MeleeWeapon`, `RangedWeapon` (и любые будущие виды оружия) — **наследники** `WeaponBase`.

Принцип «is-a»:

- Меч **является** оружием → `MeleeWeapon : WeaponBase`.
- Лук **является** оружием → `RangedWeapon : WeaponBase`.

### 0.2. Полиморфизм

- **Полиморфизм** позволяет работать с разными объектами через один общий тип.

Для нас это означает:

- `WeaponManager` хранит и использует **тип `WeaponBase`**:
  - `WeaponBase currentWeapon;`
  - при атаке вызывает просто `currentWeapon.Attack();`
- Не важно, лежит там меч, лук или магический посох:
  - каждый наследник реализует `Attack()` по‑своему;
  - код менеджера не меняется.

Это:

- упрощает логику менеджера;
- позволяет легко добавлять новые типы оружия, не переписывая существующий код.

### 0.3. Абстрактные классы и методы

В C#:

- `abstract class` — абстрактный класс, от которого создают наследников, но **не создают экземпляры напрямую**;
- `abstract`-метод — метод без реализации, который **обязан** быть реализован в каждом конкретном наследнике;
- `virtual`-метод — имеет реализацию по умолчанию, которую наследники **могут** переопределить (`override`).

В системе оружия логично:

- сделать `WeaponBase` **абстрактным** классом;
- сделать метод `Attack()` **абстрактным**, чтобы каждый вид оружия **обязан** был описать свою атаку.

### 0.4. Связь с SOLID

- **S — Single Responsibility**:
  - `WeaponData` отвечает за данные;
  - `WeaponBase` — за общую логику оружия (например, перезарядка);
  - `MeleeWeapon` / `RangedWeapon` — за конкретную механику удара/выстрела.
- **O — Open/Closed**:
  - мы можем добавлять `MagicWeapon`, `LaserWeapon` и т.д., не изменяя код `WeaponManager`, если он работает через `WeaponBase`.
- **L — Liskov Substitution**:
  - любой наследник `WeaponBase` должен корректно работать там, где ожидается `WeaponBase`:
    - если `WeaponManager` вызывает `Attack()`, оружие не должно ломать остальную систему.

---

## 1. Цели урока

- **Техническая цель**: создать абстрактный класс `WeaponBase`, который:
  - хранит ссылку на `WeaponData`;
  - управляет задержкой между атаками (перезарядкой);
  - объявляет `abstract void Attack()`.
- **Обучающая цель**: показать, как базовый класс задаёт «контракт» для всех видов оружия и как наследование + полиморфизм упрощают архитектуру.

После урока у тебя будет фундамент, от которого будут наследоваться `MeleeWeapon` и `RangedWeapon`.

---

## 2. Подготовка

Перед началом убедись, что:

1. **Урок 6.1** выполнен:
   - есть класс `WeaponData`;
   - есть несколько ассетов оружия в `Assets/ScriptableObjects/Weapons/`.
2. В проекте есть папка:
   - `Assets/Scripts/Weapons/`

---

## 3. Проектирование структуры WeaponBase

Подумай, что должно быть общим для ЛЮБОГО оружия:

- **Данные**:
  - ссылка на `WeaponData` (урон, скорость, дальность и т.д.).
- **Перезарядка**:
  - нельзя бить/стрелять чаще, чем позволяет `attackSpeed`.
- **Интерфейс для WeaponManager**:
  - метод `Attack()`, который можно вызывать независимо от типа оружия;
  - (опционально) метод/свойство `CanAttack()`.

Из этого следует структура:

- Поле `WeaponData weaponData`.
- Поле `Transform owner` (кто держит это оружие — игрок/враг).
- Поле `float nextAttackTime` — время (в секундах с начала игры), когда оружие снова готово к атаке.
- Свойства:
  - `Damage`, `Range`, `AttackSpeed` — удобные геттеры к данным.
- Методы:
  - `bool CanAttack()` — можно ли атаковать сейчас (учитывает перезарядку и то, что `weaponData` задан).
  - `void StartAttackCooldown()` — запуск задержки после удара.
  - `abstract void Attack()` — реализация атаки в наследниках.

---

## 4. Создание скрипта WeaponBase

### 4.1. Шаги в Unity

1. В окне `Project` перейди в `Assets/Scripts/Weapons/`.
2. ПКМ → `Create` → `C# Script`.
3. Назови скрипт **`WeaponBase`**.
4. Открой его в редакторе.

### 4.2. Реализация WeaponBase

Замените содержимое файла на следующий код (набирай вручную, не копируй вслепую):

```csharp
using UnityEngine;

/// <summary>
/// Базовый класс для любого оружия.
/// Хранит ссылку на WeaponData и управляет перезарядкой.
/// Наследники должны реализовать конкретный способ атаки.
/// </summary>
public abstract class WeaponBase : MonoBehaviour
{
    [Header("Данные оружия")]
    [Tooltip("ScriptableObject с базовыми параметрами оружия.")]
    public WeaponData weaponData;

    [Header("Владелец оружия (опционально)")]
    [Tooltip("Кто держит это оружие (например, Player). Используется для анимаций/направления атаки.")]
    public Transform owner;

    // Время, когда оружие снова готово атаковать (Time.time)
    protected float nextAttackTime = 0f;

    /// <summary>
    /// Текущий урон оружия, удобный геттер к WeaponData.
    /// </summary>
    public float Damage => weaponData != null ? weaponData.damage : 0f;

    /// <summary>
    /// Текущая дальность оружия.
    /// </summary>
    public float Range => weaponData != null ? weaponData.range : 0f;

    /// <summary>
    /// Скорость атаки (атак в секунду).
    /// </summary>
    public float AttackSpeed => weaponData != null ? weaponData.attackSpeed : 1f;

    /// <summary>
    /// Можно ли сейчас атаковать (учитывает перезарядку и наличие WeaponData).
    /// </summary>
    public virtual bool CanAttack()
    {
        if (weaponData == null)
        {
            Debug.LogWarning($"{name}: WeaponData не назначен, атака невозможна.", this);
            return false;
        }

        return Time.time >= nextAttackTime;
    }

    /// <summary>
    /// Устанавливает время следующей доступной атаки на основе AttackSpeed.
    /// </summary>
    protected void StartAttackCooldown()
    {
        // Если AttackSpeed = 2 → cooldown = 0.5 секунды
        float cooldown = AttackSpeed > 0f ? (1f / AttackSpeed) : 0.5f;
        nextAttackTime = Time.time + cooldown;
    }

    /// <summary>
    /// Абстрактный метод атаки.
    /// Каждый конкретный вид оружия реализует его по-своему.
    /// </summary>
    public abstract void Attack();
}
```

Обрати внимание:

- `WeaponBase` наследуется от `MonoBehaviour`, потому что мы будем вешать его (и наследников) на объекты сцены/префабы.
- Класс помечен как `abstract` — значит, **нельзя** создать компонент `WeaponBase` напрямую в Inspector, только наследников.
- Метод `Attack()` — абстрактный:
  - у него **нет** тела в базовом классе;
  - каждый наследник (`MeleeWeapon`, `RangedWeapon`) обязан реализовать его (`override`).

---

## 5. Как WeaponBase будет использоваться дальше

На следующих уроках:

- `MeleeWeapon : WeaponBase`:
  - реализует `Attack()` через поиск целей вокруг точки удара (OverlapSphere);
  - после удара вызывает `StartAttackCooldown()`.
- `RangedWeapon : WeaponBase`:
  - реализует `Attack()` через создание снаряда (`Projectile`);
  - настраивает урон и дальность снаряда;
  - тоже использует `StartAttackCooldown()`.
- `WeaponManager` на игроке:
  - хранит `WeaponBase currentWeapon`;
  - по сигналу от `InputManager` (`OnAttackPressed`) вызывает:
    - `if (currentWeapon != null) currentWeapon.Attack();`
  - не знает, ближний это бой или дальний — это и есть **полиморфизм**.

---

## 6. Мини‑проверка

Ответь на вопросы:

1. Почему `WeaponBase` сделан абстрактным, а не обычным классом?
2. Что произойдёт, если не вызывать `StartAttackCooldown()` в наследнике после атаки?
3. Какой плюс даёт наличие методов `Damage`, `Range`, `AttackSpeed` как свойств, а не повторное обращение к `weaponData` в каждом месте?

Проверь код:

- `WeaponBase` находится в папке `Assets/Scripts/Weapons/`.
- Класс помечен как `abstract`, а метод `Attack()` — как `abstract void Attack()`.
- В репозитории нет попыток повесить `WeaponBase` напрямую на `GameObject` в сцене (мы будем вешать только наследников).

Если всё это выполнено и понятно — можно переходить к уроку 6.3 (`MeleeWeapon` и `RangedWeapon` — конкретные виды оружия).

